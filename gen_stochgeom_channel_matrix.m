function [ G_ori, G_normRef] = gen_stochgeom_channel_matrix(lambdaK, lambdaL,...
    path_loss, side_length)
% Inputs: user density, relay density, path loss exponent, side length of
% square area
% Output: channel matrix 
%   G_ori : generated from original UCSD code
%   G_normRef : normalized and generated according to reference paper [1]
%           This is normalized from G_Ref with distance
%          [1] W. Lu, and M. D. Renzo, "Stochastic Geometry Modeling of ...
%          Cellular Networks: Analysis, Simulation and Experimental ...
%          Validation," In Proc. MSWiM'15

% generated by S.-E Hong, affilliated with ETRI
% note1:    I tried to model G_UMi  according to 3GPP UMi channel modeling (TR36.873)
%           For simplicity, its fast fading comes from Ref. [1]
%           As of now, I don't know how to normalize it 

%% normalization for parameters
side_length_meter = side_length * 100; % in unit of meter
MIN_distance_Ref = 1; % 1 meter for FSPL, r0 in [1]
MIN_distance_UMi = 10; % 10 meter for UMi channel model
%% dropping in a way of original code 
[xusers, yusers] = poisson_point_user_dropping(lambdaK, side_length);
% Coordinates of user locations generated by dropping them according to a
% Poisson point process

[xrelays, yrelays] = poisson_point_user_dropping(lambdaL, side_length);
% Coordinates of relay locations generated by dropping them according to a
% Poisson point process

%% mapping into real position (in 100m x 100m square)
pos_xusers = xusers * side_length_meter;
pos_yusers = yusers * side_length_meter;

pos_xrelays = xrelays * side_length_meter;
pos_yrelays = yrelays * side_length_meter;

%% setup to model fast fading
%  fast-fading envelope of the LOS links: Nakagami-m dist.
%  parameters: m = 2, omega_LOS = 1
m = 2;
omega_LOS = 1;
pd_LOS = makedist('Nakagami', 'mu', m, 'omega', omega_LOS);

%  fast-fading envelope of the NLOS links: Rayleigh dist.
%  parameters: omega_NLOS = 1
omega_NLOS = 1;
pd_NLOS = makedist('Rayleigh', 'b', omega_NLOS);

%% set channel
%% 1. initializagion of channel matrix
K = length(pos_xusers); % number of users
L = length(pos_xrelays); % number of relays
G_ori = zeros(L, K); % original channel matrix
G_Ref = zeros(L, K); % free space channel matrix with blockage ...
                     % and shadowing according to [1]
G_UMi = zeros(L, K); % 3GPP UMi channel matrix with blockage and shadowing
G_normRef = zeros(L, K);
G_normUMi = zeros(L, K);

Frequency = 2000000000; % 2 GHz = 2 * 10^9
light_speed = 300000000; % 3.0 * 10^8 m/s
        
for kk = 1:K
    for ll = 1:L
        distance = sqrt(((pos_xusers(kk) - pos_xrelays(ll))^2) +...
            ((pos_yusers(kk) - pos_yrelays(ll))^2));
        
        %% 2. Set LOS Prob. (for FSPL and UMi)
        %  according to [1] and 3GPP UMi channel modeling (TR36.873)
        if (distance <= 18)
			LOS_prob = 1;
        else
			LOS_prob = ((18. / distance) + exp(-1 * distance / 36.) *...
                (1 - (18. / distance))) ;
        end
		P = rand(1);
        
		if (P < LOS_prob)
			bool_LOS = true;
        else
			bool_LOS = false;
        end
        %% 3. Set Large Scale Path Loss 
        %  3-1 accroding to free space channel modeling [1]
        distance = max(MIN_distance_Ref, distance);
        kappa = (4 * pi * Frequency / light_speed)^2;
        if (bool_LOS == true)
            PL_exp_LOS = 2.5; % alpha_los in [1]
            sigma_SF_LOS = 5.8; % X^(LOS), in [1]
            RefPL_dB = 20. * log10(kappa) + 10. * PL_exp_LOS *...
                log10(distance) + sigma_SF_LOS * randn;
            
            % normalization: 
            norm_distance = distance / side_length_meter;
            normRefPL_dB = 10. * PL_exp_LOS *...
                log10(norm_distance) + sigma_SF_LOS * randn;
        else
            PL_exp_NLOS = 3.5; % alpha_nlos in [1]
            sigma_SF_NLOS = 8.7; % X^(NLOS), in [1]
            RefPL_dB = 20. * log10(kappa) + 10. * PL_exp_NLOS *...
                log10(distance) + sigma_SF_NLOS * randn;
            
            % normalization:
            norm_distance = distance / side_length_meter;
            normRefPL_dB = 10. * PL_exp_NLOS *...
                log10(norm_distance) + sigma_SF_NLOS * randn;
        end
        
        %  3-2 according to 3GPP UMi channel modeling (TR36.873)
        distance = max(MIN_distance_UMi, distance);
        user_height_meter = 1.5;
        relay_height_meter = 10;
        distance_3d = sqrt(distance * distance +...
            (relay_height_meter - user_height_meter) *...
            (relay_height_meter - user_height_meter)); %3D distance
        d_BP = 4 * (user_height_meter - 1) * (relay_height_meter - 1) *...
            Frequency / light_speed; % break point distance = 120 m
        if (bool_LOS == true)
            if (distance <= d_BP)
                sigma_SF = 3;
                UMiPL_dB = 28. + 22. * log10(distance_3d) +...
                    20. * log10(Frequency / 1000000000.) +...
                    sigma_SF * randn;
            else
                sigma_SF = 3;
                UMiPL_dB = 40. * log10(distance_3d) + 28 +...
                    20. * log10(Frequency / 1000000000.) -...
                    9 * log10(power(d_BP, 2) + power((relay_height_meter - user_height_meter), 2)) +...
                    sigma_SF * randn;
            end
        else % bool_LOS == false
            if (distance <= d_BP)
                sigma_SF = 4;
                UMiPL_dB = 28. + 22. * log10(distance_3d) +...
                    20. * log10(Frequency / 1000000000.) +...
                    sigma_SF * randn;
            else
                sigma_SF = 4;
                UMiPL_dB = 40. * log10(distance_3d) + 28 +...
                    20. * log10(Frequency / 1000000000.) -...
                    9 * log10(power(d_BP, 2) + power((relay_height_meter - user_height_meter), 2)) +...
                    sigma_SF * randn;
            end
            UMiPL2_dB = 22.7 + 36.7 * log10(distance_3d) +...
                    26. * log10(Frequency / 1000000000.) +...
                    sigma_SF * randn;
            UMiPL_dB = max(UMiPL_dB, UMiPL2_dB);             
        end
        %% 4. Set Small Scale (fast fading) Path Loss
        %  This is modeled according to Ref. [1]
        if (bool_LOS == true)
            %  fast-fading envelope of the LOS links: Nakagami-m dist.
            %  parameters: m = 2, omega_LOS = 1
            rv_LOS = random(pd_LOS);
            EnvFF_dB = 10 * log10(rv_LOS); % Envelope for FF in dB 
        else % bool_LOS == false
            %  fast-fading envelope of the NLOS links: Rayleigh dist.
            %  parameters: omega_NLOS = 1
            rv_NLOS = random(pd_NLOS);
            EnvFF_dB = 10 * log10(rv_NLOS); % Envelope for FF in dB
        end
        
        RefPL_dB = RefPL_dB + EnvFF_dB;
        normRefPL_dB = normRefPL_dB + EnvFF_dB;
        
        UMiPL_dB = UMiPL_dB + EnvFF_dB;
        
        %% 5. Set Channel Gain Matrix 
        dist_ori = (((pos_xusers(kk) - pos_xrelays(ll))^2) +...
            ((pos_yusers(kk) - pos_yrelays(ll))^2))^0.5;
        dist_threshold = 1;
%        G_ori(ll, kk) = (((xusers(kk) - xrelays(ll))^2) +...
%            ((yusers(kk) - yrelays(ll))^2))^(-path_loss/2);
        G_ori(ll, kk) = (max(dist_ori, dist_threshold)/side_length_meter)^-path_loss;
        % channel components generated according to path loss exponent;
        % given user locations, no extra randomness in channel 
        
        G_Ref(ll, kk) = power(10, -1*RefPL_dB/10); 
        G_normRef(ll, kk) = power(10, -1*normRefPL_dB/10); 
        G_UMi(ll, kk) = power(10, -1*UMiPL_dB/10);
    end
end

end

